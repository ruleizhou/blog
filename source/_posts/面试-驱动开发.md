---
title: 面试-驱动开发
typora-root-url: 面试-驱动开发
date: 2020-06-25 20:36:10
categories:
- 面试
tags:
- 面试
typora-copy-images-to: 面试-驱动开发
---

# Linux相关

## Linux中用户模式和内核模式是什么含意？

## linux用户进程间通信主要有哪几种方式？

## linux内存如何划分及如何使用？虚拟地址及物理地址的概念及转换，高端内存的概念？

## linux中内核空间和用户空间区别？用户空间和内核空间通信方式有哪些？

## linux中系统调用过程？如应用程序中read()在linux中执行过程（从用户空间到内核空间）？

## linux调度原理

## linux RCU原理

## linux编译时用到的参数含义

## linux内核的启动过程（源代码级）

# 基础相关

## 怎么用C先嵌入式系统的死循环的？

## copy_to_user() 和copy_from_user()主要用于实现什么功能？一般用于file_operations结构的哪些函数里面？

## ioctl和unlock_ioctl有什么区别？

## kmalloc和vmalloc的区别

## 内核函数mmap的实现原理，机制？

## 怎样申请大块内核内存？

## framebuffer机制

## 内核配置编译及Makefile

## 列举最少3种你所知道的嵌入式的体系结构，并请说明什么时ARM体系结构？

# 驱动模型相关

## 字符设备和块设备的区别，请分别列举一些实际的设备说出它们是属于哪一类设备？

## 请简述主设备号和次设备号的用途。如果执行mknod chartest c 4 64，创建chartest设备。请分析chartest使用的是哪一类设备驱动程序？

## 设备驱动程序中如何注册一个字符设备？分别解释下它的几个参数的含义？

## 字符型驱动设备怎么创建文件？

## insmod一个驱动模块，会执行模块中的哪个函数？rmmod呢？这两个函数在设计上要注意哪些？遇到过卸载驱动出现异常没？是什么问题引起的？

## 设备驱动模型三个重要的成员是？platform总线的匹配规则是？在具体应用上要不要先注册驱动在注册设备？有先后顺序没？

## 驱动中操作物理绝对地址为什么要先ioremap？

## 查看驱动模块中打印信息应该使用什么命令？如何查看内核中已有的字符设备的信息？如何查看正在使用的哪些中断号？

# Bus相关

## IIC原理，总线框架，设备编写方法，i2c_msg

# Debug相关

## kernel panic

## 在驱动调试过程中遇到过oops没？怎么处理的？

# 同步相关

## spinlock与信号量的区别？

## linux中的同步机制？

## linux系统实现原子操作有哪些方法？

## 自旋锁和信号量在互斥使用时需要注意哪些？在中断服务程序里面的互斥是使用自旋锁还是信号量？还是两者都能用？为什么

## 驱动里面为什么要有并发、互斥的控制？如何实现？讲个例子？

# 中断相关

## 系统软中断、tasklet、工作队列work queue的区别及使用

中断上半部：

- 对时间要求比较高的工作
- 硬件相关的操作
- 不能被中断打断，因为进入中断时候一般都会禁止本地CPU中断

中断下半部：

- 可延迟执行的操作（对时间要求不高）

### 软中断

目前Linux系统最多支持32个软中断，系统已经定义使用了10个，剩下的用户可以自己指定。

```c
enum
{
    HI_SOFTIRQ=0,
    TIMER_SOFTIRQ,
    NET_TX_SOFTIRQ,
    NET_RX_SOFTIRQ,
    BLOCK_SOFTIRQ,
    BLOCK_IOPOLL_SOFTIRQ,
    TASKLET_SOFTIRQ,
    SCHED_SOFTIRQ,
    HRTIMER_SOFTIRQ,
    RCU_SOFTIRQ,    /* Preferable RCU should always be the last softirq */

    NR_SOFTIRQS
};
```

上面列出的软中断类型越靠前优先级越高，其中有两个需要关注一下，就是HI_SOFTIRQ和TASKLET_SOFTIRQ，系统已经帮我们初始化好了，tasklet就是基于这两个软中断去实现的。具体代码如下:

```c
//init/main.c
asmlinkage __visible void __init start_kernel(void)
{
    char *command_line;
    char *after_dashes;

    /*
     * Need to run as early as possible, to initialize the
     * lockdep hash:
     */
    lockdep_init();
    set_task_stack_end_magic(&init_task);
    smp_setup_processor_id();
    debug_objects_early_init();

    /*
     * Set up the the initial canary ASAP:
     */
    boot_init_stack_canary();

    cgroup_init_early();

    local_irq_disable();
    early_boot_irqs_disabled = true;

    ....    ....

    /*
     * These use large bootmem allocations and must precede
     * kmem_cache_init()
     */
    setup_log_buf(0);
    pidhash_init();
    vfs_caches_init_early();
    sort_main_extable();
    trap_init();
    mm_init();
    ....    ....
    early_irq_init();
    init_IRQ();
    tick_init();
    rcu_init_nohz();
    init_timers();
    hrtimers_init();
    softirq_init();//初始化软中断
    timekeeping_init();
    time_init();
    ....
    ....
    ....
#ifdef CONFIG_X86_ESPFIX64
    /* Should be run before the first non-init thread is created */
    init_espfix_bsp();
#endif
    thread_info_cache_init();
    cred_init();
    fork_init();
    ....    ....

    check_bugs();

    acpi_subsystem_init();
    sfi_init_late();

    if (efi_enabled(EFI_RUNTIME_SERVICES)) {
        efi_late_init();
        efi_free_boot_services();
    }

    ftrace_init();

    /* Do the rest non-__init'ed, we're now alive */
    rest_init();
}


//kernel/softirq.c
void __init softirq_init(void)
{
    int cpu;

    for_each_possible_cpu(cpu) {
        per_cpu(tasklet_vec, cpu).tail =
            &per_cpu(tasklet_vec, cpu).head;
        per_cpu(tasklet_hi_vec, cpu).tail =
            &per_cpu(tasklet_hi_vec, cpu).head;
    }

    open_softirq(TASKLET_SOFTIRQ, tasklet_action);
    open_softirq(HI_SOFTIRQ, tasklet_hi_action);
}
```

其中：

open_softirq(TASKLET_SOFTIRQ, tasklet_action);

open_softirq(HI_SOFTIRQ, tasklet_hi_action);

就是系统为我们初始化好的和tasklet相关的软中断。

#### 自定义软中断

我们也可以自己定义属于自己的软中断，方法如下:

1. 添加我们自己的软中断

   ```c
   enum
   {
       HI_SOFTIRQ=0,
       TIMER_SOFTIRQ,
       NET_TX_SOFTIRQ,
       NET_RX_SOFTIRQ,
       BLOCK_SOFTIRQ,
       BLOCK_IOPOLL_SOFTIRQ,
       TASKLET_SOFTIRQ,
       SCHED_SOFTIRQ,
       HRTIMER_SOFTIRQ,
       MY_SOFTIRQ,      /*我自己添加的软中断*/ 
       RCU_SOFTIRQ,    /* Preferable RCU should always be the last softirq */
   
       NR_SOFTIRQS
   };
   ```

2. 在kernel/softirq.c中定义自己的软中断处理函数

   ```c
   //我自己定义的软中断处理函数
   static void my_softirq_action(struct softirq_action *a)
   {
       ...
   }
   ```

3. 初始化

   ```c
   void __init softirq_init(void)
   {
       int cpu;
   
       for_each_possible_cpu(cpu) {
           per_cpu(tasklet_vec, cpu).tail =
               &per_cpu(tasklet_vec, cpu).head;
           per_cpu(tasklet_hi_vec, cpu).tail =
               &per_cpu(tasklet_hi_vec, cpu).head;
       }
   
       open_softirq(TASKLET_SOFTIRQ, tasklet_action);
       open_softirq(HI_SOFTIRQ, tasklet_hi_action);
       open_softirq(MY_SOFTIRQ, tasklet_hi_action);//我自己定义的软中断
   }
   ```

4. 激活

   ```c
   raise_softirq(MY_SOFTIRQ);
   ```

以上就是自己定义的软中断的流程。

#### 软中断的执行

软中断的执行既可以守护进程(ksoftirqd)中执行，也可以在中断的退出阶段执行。实际上，软中断更多的是在中断的退出阶段执行（irq_exit），以便达到更快的响应，加入守护进程机制，只是担心一旦有大量的软中断等待执行，会使得内核过长地留在中断上下文中。

##### 在irq_exit中执行

```c
void irq_exit(void)
{
        ......
	sub_preempt_count(IRQ_EXIT_OFFSET);
	if (!in_interrupt() && local_softirq_pending())
		invoke_softirq();
        ......
}
```

如果中断发生嵌套，in_interrupt()保证了只有在最外层的中断的irq_exit阶段，invoke_interrupt才会被调用，当然，local_softirq_pending也会实现判断当前cpu有无待决的软中断。代码最终会进入__do_softirq中，内核会保证调用__do_softirq时，本地cpu的中断处于关闭状态，进入__do_softirq：

```c
asmlinkage void __do_softirq(void)
{
        ......
	pending = local_softirq_pending();
 
	__local_bh_disable((unsigned long)__builtin_return_address(0),
				SOFTIRQ_OFFSET);
restart:
	/* Reset the pending bitmask before enabling irqs */
	set_softirq_pending(0);
 
	local_irq_enable();
 
	h = softirq_vec;
 
	do {
		if (pending & 1) {
	                ......
			trace_softirq_entry(vec_nr);
			h->action(h);
			trace_softirq_exit(vec_nr);
                        ......
		}
		h++;
		pending >>= 1;
	} while (pending);
 
	local_irq_disable();
 
	pending = local_softirq_pending();
	if (pending && --max_restart)
		goto restart;
 
	if (pending)
		wakeup_softirqd();
 
	lockdep_softirq_exit();
 
	__local_bh_enable(SOFTIRQ_OFFSET);
}
```

- 首先取出pending的状态；
- 禁止软中断，主要是为了防止和软中断守护进程发生竞争；
- 清除所有的软中断待决标志
- 打开本地cpu中断；
- 循环执行待决软中断的回调函数
- 如果循环完毕，发现新的软中断被触发，则重新启动循环，直到以下条件满足，才退出：
  - 没有新的软中断等待执行
  - 循环已经达到最大的循环次数MAX_SOFTIRQ_RESTART，目前的设定值时10次；
- 如果经过MAX_SOFTIRQ_RESTART次循环后还未处理完，则激活守护进程，处理剩下的软中断；
- 退出前恢复软中断

##### 在ksoftirqd进程中执行

软中断也可能由ksoftirqd守护进程执行，这要发生在以下两种情况下：

- 在irq_exit中执行软中断，但是在经过MAX_SOFTIRQ_RESTART次循环后，软中断还未处理完，这种情况虽然极少发生，但毕竟有可能；
- 内核的其它代码主动调用raise_softirq，而这时正好不是在中断上下文中，守护进程将被唤醒；

守护进程最终也会调用\__do_softirq执行软中断的回调，具体的代码位于run_ksoftirqd函数中，内核会关闭抢占的情况下执行__do_softirq。

### tasklet

因为内核已经定义好了10种软中断类型，并且不建议我们自行添加额外的软中断，所以对软中断的实现方式，我们主要是做一个简单的了解，对于驱动程序的开发者来说，无需实现自己的软中断。但是，对于某些情况下，我们不希望一些操作直接在中断的handler中执行，但是又希望在稍后的时间里得到快速地处理，这就需要使用tasklet机制。 tasklet是建立在软中断上的一种延迟执行机制，它的实现基于TASKLET_SOFTIRQ和HI_SOFTIRQ这两个软中断类型。

tasklet示例如下：

1. 定一个tasklet类型的结构体变量

   ```c
   /*使用tasklet机制的中断下半部*/
   struct tasklet_struct my_tasklet;
   ```

2. 编写软中断处理函数

   ```c
   static void my_tasklet_fun(unsigned long arg){
   	...
   }
   ```

3. 初始化，将tasklet软中断处理函数和tasklet挂钩

   ```c
   tasklet_init(my_tasklet,my_tasklet_fun,(unsigned long) sport);
   ```

4. 调用tasklet_schedule触发调度tasklet

   ```c
   tasklet_schedule(&sport->my_tasklet);//调度tasklet
   ```

定义tasklet变量，实现软中断处理函数，初始化，调度，以上这些就是tasklet的使用步骤了，内核帮我们省略了很多麻烦的实现，所以使用起来比较简单。

### 工作队列work queue

软中断和tasklet是运行于中断上下文的，它们属于内核态没有进程的切换，因此在执行过程中不能休眠，不能阻塞，一旦休眠或者阻塞，则系统直接挂死。因此软中断和tasklet是有一定的使用局限性的，工作队列的出现正是用在软中断和tasklet不能使用的场合，比如需要调用一个具有可延迟函数的特质，但是这个函数又有可能引起休眠、阻塞。

工作队列的使用步骤如下：

1. 定义一个工作队列对象

   ```c
   /*工作队列机制*/
   struct work_struct    my_work;
   ```

2. 编写工作队列处理函数

   ```c
   /*工作队列机制*/
   static void my_work_fun(struct work_struct *w){
       ...
   }
   ```

3. 初始化工作队列

   ```c
   INIT_WORK(&my_work, my_work_fun);
   ```

4. 调度工作队列

   ```c
   schedule_work(&my_work);
   ```

   

## linux中断响应的执行流程

![](/中断相应流程图.png)

这个序列图展示了整个通用中断子系统的中断响应过程，flow_handle一栏就是中断流控层的生命周期

## 中断注册函数和中断注销函数

```c
request_threaded_irq(unsigned int irq,
                     irq_handler_t handler,
                     irq_handler_t thread_fn,
                     unsigned long flags,
                     const char *name,
                     void *dev);
```

- irq

  需要申请的irq编号，对于ARM体系，irq编号通常在平台级的代码中事先定义好，有时候也可以动态申请。

- handler

  中断服务回调函数，该回调运行在中断上下文中，并且cpu的本地中断处于关闭状态，所以该回调函数应该只是执行需要快速响应的操作，执行时间应该尽可能短小，耗时的工作最好留给下面的thread_fn回调处理。

- thread_fn

  如果该参数不为NULL，内核会为该irq创建一个内核线程，当中断发生时，如果handler回调返回值是IRQ_WAKE_THREAD，内核将会激活中断线程，在中断线程中，该回调函数将被调用，所以，该回调函数运行在进程上下文中，允许进行阻塞操作。

- flags

  控制中断行为的位标志。例如：IRQF_TRIGGER_RISING，IRQF_TRIGGER_LOW，IRQF_SHARED等，在include/linux/interrupt.h中定义。

- name

  申请本中断服务的设备名称，同时也作为中断线程的名称，该名称可以在/proc/interrupts文件中显示。

- dev

  当多个设备的中断线共享同一个irq时，它会作为handler的参数，用于区分不同的设备。

## 中断和轮询哪个效率高？怎样决定是采用中断方式还是采用轮询方式去实现驱动？

中断是CPU处于被动状态下来接受设备的信号，而轮询是CPU主动去查询该设备是否有请求。凡事都是两面性，所以，看效率不能简单的说那个效率高。如果是请求设备是一个频繁请求cpu的设备，或者有大量数据请求的网络设备，那么轮询的效率是比中断高。如果是一般设备，并且该设备请求cpu的频率比较底，则用中断效率要高一些。主要是看请求频率

## 写一个中断服务需要注意哪些？如果中断产生之后要做比较多的事情你是怎么做的？

- 中断处理例程应该尽量短**，**把能放在后半段(tasklet，等待队列等)的任务尽量放在后半段
- 中断服务程序中不能有阻塞操作。应为中断期间是完全占用CPU的（即不存在内核调度），中断被阻塞住，其他进程将无法操作；
- 中断服务程序注意返回值，要用操作系统定义的宏做为返回值，而不是自己定义的OK，FAIL之类的。

## 驱动中操作物理绝对地址为什么要先ioremap?

因为内核没有办法直接访问物理内存地址，必须先**通过ioremap获得对应的虚拟地址**。

## IRQ和FIQ有什么区别？

一般的中断控制器里我们可以配置与控制器相连的某个中断输入是FIQ还是IRQ,所以一个中断是可以指定为FIQ或者IRQ的，为了合理，要求系统更快响应，自身处理所耗时间也很短的中断设置为FIQ，否则就设置了IRQ。

区别如下：

- FIQ比IRQ有更高优先级
- IRQ可以被FIQ所中断，但FIQ不能被IRQ所中断。
- FIQ模式下，比IRQ模式多了几个独立的寄存器

